## 减少Servlet数量
    参照SpringMVC，仅通过DispatcherServlet进行请求派发；
    
    拦截所有请求
    解析请求
    派发给对应的Controller里面的方法进行处理
    
## 简单工程模式
    定义一个工厂类，根据传入的参数的值不同返回不同的实例
    特点：被创建的实例具有共同的父类或接口；
    使用场景：
        需要创建的对象较少
        客户端不关心对象的创建对象
     优缺点：
        优点：可以对创建的对象进行"加工"，对客户端隐藏相关细节
        缺点：因创建逻辑复杂或创建对象过多而造成代码臃肿
        缺点：新增、删除子类均会违反开闭原则
        对于实体类来说是符合开闭原则的，但是对于简单工厂却不是
     开闭原则：
        一个软件实体，应该对拓展开放，对修改关闭
            应该通过拓展来实现变化，而不是通过修改已有的代码来实现变化
     所有原则并非一定严格遵守，而是需要结合业务的实际情况
     
## 工厂方法模式
    定义一个用于创建对象的接口，让子类决定实例化那一个类
        对象的实例化延迟到其子类
    优点：
        遵循开闭原则
        对客户端隐藏对象的创建细节
        遵循单一职责
    简单工厂模式是简单工厂模式的进一步抽象和拓展，但是也有其不足
        添加子类的时候"拖家带口"，代码臃肿；
        只支持同一类产品的创建
## 抽象工厂模式
    提供一个创建一系列相关或相互依赖对象的接口
        抽象工厂模式侧重的是同一产品族
        工厂方法模式更加侧重于同一产品等级
    解决了工厂模式只支持生产一种产品的弊端
        新增一个产品族，只需要增加一个新的具体工厂，不需要修改代码；
    对工厂模式进行了抽象
        工厂方法模式：每一个抽象产品派生多个具体产品类，每个抽象工厂类派生多个具体工厂类，每个具体工厂类负责一个具体产品的实例创建
    抽象工厂模式：每个抽象产品派生多个具体产品类，每个抽象工厂派生多个具体工厂类，每个具体工厂负责一系列具体产品的实例创建
    
    
    特点：添加新产品时依旧违背开闭原则，增加系统复杂度；
    
    spring是结合了工厂模式和反射机制的SpringIOC容器来降低系统复杂度；
    
    
## 反射
    允许程序在运行时来进行自我检查并且对内部的成员进行操作
    
    反射主要是指程序课可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义；
    
    反射机制的作用:
        在运行时判断任意一个对象所属的类
        在运行时获取类的对象
        在运行时方位Java对象的属性，方法，构造方法等
        
     java.lang.reflect类库里面主要的类
        Field:表示类中的成员变量
        Method:表示类中的方法
        Constructor:表示类的构造方法
        Array:该类提供了动态创建数组和访问数组元素的静态方法；
     反射依赖的Class:
        用来表示运行时类型信息的对应类
            每一个类都有唯一一个与之相对应的Class对象
            Class类为类类型，而Class对象为类类型对象
     Class类的特点：
        Class类也是类的一种，class则是关键字
        Class类只有一个私有的构造函数，只有JVM能够创建Class类的实例
        JVM中只有唯一一个和类相对应的Class对象来描述其类型信息
     获取Class对象的三种形式
        Oject->getClass()
        任何数据类型（包括基本数据类型）都有一个"静态"的class属性
        通过Class类的静态方法：forName(Stirng className)（常用）
        在运行期间，一个类，只有一个与之相对应的Class对象产生
     Class对象就像一面镜子，透过这面镜子可以看到类的结构
     
## 注解
    提供一种为程序元素设置元数据的方法
        元数据是添加到程序元素如方法、字段、类和包上的额外信息；
        注解是一种分散式的元数据设置方式，XML是集中式的设置方式。
        注解不能直接干扰程序代码的运行
    功能：
        作为特定的标记，用于告诉编译器一些信息
        编译时动态处理，如动态生成代码
        运行时动态处理，作为额外信息的载体，如获取注解信息
        
    分类：
        标准注解：Override、Deprecated、SuppressWarnings
        
        元注解：用于修饰注解的注解，通常用在注解的定义上
            @Retention：注解的生命周期
                
            @Target:注解的作用目标，描述所修饰的注解的使用范围
                
            @Inherited：是否允许子类继承该注解
                
            @Documented：注解是否应当被包含在JavaDoc文档中
                
        
        
        自定义注解
        
    注解获取属性值的底层实现：
        JVM会为注解生成代理对象
        
## 上述学习对自研框架的意义
    使用注解标记需要工厂管理的实例，并依据注解属性做精细控制
            
## 控制反转
    依托一个类似工厂的IOC容器
    将对象的创建、依赖关系的管理以及生命周期交由IoC容器管理
    降低系统在实现上的复杂性和耦合度，易于拓展，满足开闭原则
    
    
    Spring Core 最核心的部分
    需要先了解依赖注入（dependency Inversion）
    
    用依赖注入DI实现控制反转
        含义：把底层类作为参数传递给上层类，实现上层对下层的"控制"
        
    依赖注入的方式：
        Setter
        Interface
        Constructor
        Annotation
        
     IoC容器的优势：
        避免在各处使用new来创建类，并且可以做到统一维护
        创建实例的时候不需要了解其中的细节
        反射+工厂模式的合体，满足开闭原则
        
    